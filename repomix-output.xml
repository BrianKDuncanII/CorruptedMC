This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: README.txt, changelog.txt, LICENSE.txt, gradlew, gradlew.bat, CREDITS.txt, build.gradle, .gitignore, ./run, ./run-data, ./.vscode, ./.gradle, .gitattributes, gradle/wrapper/gradle-wrapper.properties, pack.mcmeta, sounds.json, mods.toml
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
gradle.properties
Info For Gemini.txt
settings.gradle
src/main/java/com/roesilej/corruptedmc/block/CorruptedBlock.java
src/main/java/com/roesilej/corruptedmc/client/ClientEvents.java
src/main/java/com/roesilej/corruptedmc/client/CorruptionHudOverlay.java
src/main/java/com/roesilej/corruptedmc/command/SetCorruptionRateCommand.java
src/main/java/com/roesilej/corruptedmc/command/TriggerEventCommand.java
src/main/java/com/roesilej/corruptedmc/config/CorruptionRateConfig.java
src/main/java/com/roesilej/corruptedmc/CorruptedMC.java
src/main/java/com/roesilej/corruptedmc/corruption/ClientCorruptionData.java
src/main/java/com/roesilej/corruptedmc/corruption/CorruptionData.java
src/main/java/com/roesilej/corruptedmc/event/CorruptionEvents.java
src/main/java/com/roesilej/corruptedmc/event/ServerEvents.java
src/main/java/com/roesilej/corruptedmc/init/ModBlocks.java
src/main/java/com/roesilej/corruptedmc/init/ModItems.java
src/main/java/com/roesilej/corruptedmc/loot_tables/blocks/corrupted_block.json
src/main/java/com/roesilej/corruptedmc/network/ModMessages.java
src/main/java/com/roesilej/corruptedmc/network/packet/CorruptionDataSyncS2CPacket.java
src/main/resources/assets/corruptedmc/blockstates/corrupted_block.json
src/main/resources/assets/corruptedmc/models/block/corrupted_block.json
src/main/resources/assets/corruptedmc/models/item/corrupted_block.json
src/main/resources/META-INF/mods.toml
src/main/resources/pack.mcmeta
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Info For Gemini.txt">
If you've read this text, please acknowledge it in your response.
- I'm using Visual Studio Code for this project.
- When you provide code please provide the entire code, not just snippets or new additions.
</file>

<file path="settings.gradle">
pluginManagement {
    repositories {
        gradlePluginPortal()
        maven {
            name = 'MinecraftForge'
            url = 'https://maven.minecraftforge.net/'
        }
    }
}

plugins {
    id 'org.gradle.toolchains.foojay-resolver-convention' version '0.7.0'
}
</file>

<file path="src/main/java/com/roesilej/corruptedmc/block/CorruptedBlock.java">
public class CorruptedBlock extends Block {
⋮----
public void randomTick(BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {
// This method is called randomly on blocks that have .randomTicks() enabled.
⋮----
// Don't do anything on the client
if (world.isClientSide()) {
⋮----
// --- THIS CHECK HAS BEEN REMOVED FOR TESTING ---
// if (random.nextInt(4) != 0) {
//     return;
// }
⋮----
// Check a 3x3x3 area around the block
for (int i = 0; i < 4; i++) { // Try to spread a few times
BlockPos nearbyPos = pos.offset(random.nextInt(3) - 1, random.nextInt(3) - 1, random.nextInt(3) - 1);
BlockState nearbyState = world.getBlockState(nearbyPos);
⋮----
// Check if the nearby block is a valid target for corruption
if (isValidTarget(nearbyState)) {
world.setBlock(nearbyPos, ModBlocks.CORRUPTED_BLOCK.get().defaultBlockState(), 3);
return; // Stop after spreading once
⋮----
private boolean isValidTarget(BlockState state) {
// Define which blocks can be corrupted.
// Avoid corrupting air, bedrock, or other important blocks.
return state.is(Blocks.STONE) || state.is(Blocks.DIRT) || state.is(Blocks.GRASS_BLOCK) || state.is(Blocks.ANDESITE) || state.is(Blocks.DIORITE) || state.is(Blocks.GRANITE);
</file>

<file path="src/main/java/com/roesilej/corruptedmc/command/SetCorruptionRateCommand.java">
public class SetCorruptionRateCommand {
⋮----
public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
// Register the main command literal "corruptionrate"
dispatcher.register(Commands.literal("corruptionrate")
// Require operator permission level 2 to use this command
.requires(source -> source.hasPermission(2))
⋮----
// Sub-command: /corruptionrate set <multiplier>
.then(Commands.literal("set")
.then(Commands.argument("multiplier", FloatArgumentType.floatArg(0)) // Argument must be a float >= 0
.executes(context -> {
float multiplier = FloatArgumentType.getFloat(context, "multiplier");
CorruptionRateConfig.setRateMultiplier(multiplier);
// Send feedback to the player who ran the command
context.getSource().sendSuccess(() -> Component.literal("Corruption rate multiplier set to " + multiplier), true);
return 1; // Indicates command was successful
⋮----
// Sub-command: /corruptionrate get
.then(Commands.literal("get")
⋮----
float multiplier = CorruptionRateConfig.getRateMultiplier();
⋮----
context.getSource().sendSuccess(() -> Component.literal("Current corruption rate multiplier is " + multiplier), false);
</file>

<file path="src/main/java/com/roesilej/corruptedmc/command/TriggerEventCommand.java">
public class TriggerEventCommand {
⋮----
// An array of your event names. Easy to add to later!
⋮----
// "another_event", "a_third_event"
⋮----
public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
dispatcher.register(Commands.literal("corruptevent")
.requires(source -> source.hasPermission(2)) // Operator level 2
.then(Commands.literal("trigger")
.then(Commands.argument("eventName", StringArgumentType.string())
.suggests(TriggerEventCommand::getEventSuggestions) // Adds tab-completion
.executes(TriggerEventCommand::runEvent))));
⋮----
private static int runEvent(CommandContext<CommandSourceStack> context) {
String eventName = StringArgumentType.getString(context, "eventName");
CommandSourceStack source = context.getSource();
⋮----
switch (eventName.toLowerCase()) {
⋮----
success = CorruptionEvents.triggerCorruptionSpreadEvent(source.getLevel());
⋮----
success = CorruptionEvents.triggerExplosionEvent(source.getLevel());
⋮----
// Add more cases here for future events
// case "another_event":
//     success = CorruptionEvents.triggerAnotherEvent(source.getLevel());
//     break;
⋮----
source.sendFailure(Component.literal("Unknown event name: '" + eventName + "'"));
return 0; // Command failed
⋮----
source.sendSuccess(() -> Component.literal("Successfully triggered event: '" + eventName + "'"), true);
return 1; // Command succeeded
⋮----
source.sendFailure(Component.literal("Failed to trigger event: '" + eventName + "'. Conditions may not have been met (e.g., no players online or no valid location found)."));
⋮----
private static CompletableFuture<Suggestions> getEventSuggestions(CommandContext<CommandSourceStack> context, SuggestionsBuilder builder) {
return SharedSuggestionProvider.suggest(CORRUPTION_EVENTS, builder);
</file>

<file path="src/main/java/com/roesilej/corruptedmc/config/CorruptionRateConfig.java">
public class CorruptionRateConfig {
// This is the default probability of corruption increasing each server tick.
⋮----
// This multiplier will be adjusted by our command. It starts at 1 for the default rate.
⋮----
/**
     * Sets the multiplier for the corruption rate.
     * @param multiplier The new multiplier. Value is clamped to be non-negative.
     */
public static void setRateMultiplier(float multiplier) {
// We use Math.max to prevent anyone from setting a negative multiplier.
CorruptionRateConfig.rateMultiplier = Math.max(0, multiplier);
⋮----
/**
     * Gets the current corruption rate multiplier.
     * @return The current multiplier.
     */
public static float getRateMultiplier() {
⋮----
/**
     * Calculates the effective rate by combining the default rate and the multiplier.
     * @return The final probability for the corruption tick.
     */
public static float getEffectiveRate() {
</file>

<file path="src/main/java/com/roesilej/corruptedmc/corruption/ClientCorruptionData.java">
public class ClientCorruptionData {
⋮----
public static void setCorruptionLevel(float level) {
⋮----
public static float getCorruptionLevel() {
</file>

<file path="src/main/java/com/roesilej/corruptedmc/event/CorruptionEvents.java">
public class CorruptionEvents {
⋮----
/**
     * Attempts to place a single Corrupted Block near a random player in the world.
     * This is the "block spread" event.
     * @param world The server world to perform the event in.
     * @return True if the event succeeded, false otherwise.
     */
public static boolean triggerCorruptionSpreadEvent(ServerLevel world) {
// Pick a random player
if (world.getServer().getPlayerCount() == 0) return false;
ServerPlayer player = world.getServer().getPlayerList().getPlayers().get(world.getRandom().nextInt(world.getServer().getPlayerCount()));
⋮----
// Try to find a suitable block to corrupt around the player
for (int i = 0; i < 15; i++) { // Try 15 times to find a spot
BlockPos targetPos = player.blockPosition().offset(
world.getRandom().nextInt(20) - 10, // Increased range slightly
world.getRandom().nextInt(10) - 5,
world.getRandom().nextInt(20) - 10
⋮----
BlockState targetState = world.getBlockState(targetPos);
// We can reuse the same validation logic from the CorruptedBlock class
if (targetState.is(Blocks.STONE) || targetState.is(Blocks.DIRT) || targetState.is(Blocks.GRASS_BLOCK)) {
world.setBlock(targetPos, ModBlocks.CORRUPTED_BLOCK.get().defaultBlockState(), 3);
// Optional: Notify the server console that the event was triggered
// CorruptedMC.LOGGER.info("Triggered 'spread' event at: " + targetPos);
return true; // The event was successful
⋮----
return false; // Failed to find a suitable location
⋮----
/**
     * Triggers a small, non-destructive explosion near a random player.
     * @param world The server world to perform the event in.
     * @return True if the event succeeded, false otherwise.
     */
public static boolean triggerExplosionEvent(ServerLevel world) {
⋮----
// Find a random position near the player for the explosion
BlockPos explosionPos = player.blockPosition().offset(
world.getRandom().nextInt(16) - 8, // x-offset between -8 and 7
0,                                 // y-offset at player's feet level to avoid underground/sky explosions
world.getRandom().nextInt(16) - 8  // z-offset between -8 and 7
⋮----
// Create an explosion that doesn't break blocks but still damages entities
// To make it destroy blocks, change Level.ExplosionInteraction.NONE to Level.ExplosionInteraction.BLOCK
world.explode(null, explosionPos.getX(), explosionPos.getY(), explosionPos.getZ(), 2.0f, Level.ExplosionInteraction.NONE);
⋮----
// This event is considered successful once the explosion is triggered
⋮----
// You can add more public static methods here for future events!
// public static boolean triggerAnotherEvent(ServerLevel world) { ... }
</file>

<file path="src/main/java/com/roesilej/corruptedmc/init/ModBlocks.java">
import net.minecraft.world.level.block.Blocks; // <-- Add this import
⋮----
// import net.minecraft.world.level.material.Material; // <-- REMOVE this import
⋮----
public class ModBlocks {
⋮----
DeferredRegister.create(ForgeRegistries.BLOCKS, CorruptedMC.MODID);
⋮----
// Register the new Corrupted Block
public static final RegistryObject<Block> CORRUPTED_BLOCK = registerBlock("corrupted_block",
// V-- THIS IS THE CORRECTED LINE --V
() -> new CorruptedBlock(BlockBehaviour.Properties.copy(Blocks.STONE)
.strength(2.0f, 6.0f)
.requiresCorrectToolForDrops()
.randomTicks())); // This is crucial for spreading!
⋮----
// Helper method for registering blocks
private static <T extends Block> RegistryObject<T> registerBlock(String name, Supplier<T> block) {
return BLOCKS.register(name, block);
</file>

<file path="src/main/java/com/roesilej/corruptedmc/init/ModItems.java">
public class ModItems {
⋮----
DeferredRegister.create(ForgeRegistries.ITEMS, CorruptedMC.MODID);
⋮----
// Register the BlockItem for our Corrupted Block
public static final RegistryObject<Item> CORRUPTED_BLOCK_ITEM = ITEMS.register("corrupted_block",
() -> new BlockItem(ModBlocks.CORRUPTED_BLOCK.get(), new Item.Properties()));
</file>

<file path="src/main/java/com/roesilej/corruptedmc/loot_tables/blocks/corrupted_block.json">
{
  "type": "minecraft:block",
  "pools": [
    {
      "rolls": 1,
      "entries": [
        {
          "type": "minecraft:item",
          "name": "corruptedmc:corrupted_block"
        }
      ],
      "conditions": [
        {
          "condition": "minecraft:survives_explosion"
        }
      ]
    }
  ]
}
</file>

<file path="src/main/java/com/roesilej/corruptedmc/network/ModMessages.java">
public class ModMessages {
⋮----
private static int id() {
⋮----
public static void register() {
⋮----
.named(new ResourceLocation(CorruptedMC.MODID, "messages"))
.networkProtocolVersion(() -> "1.0")
.clientAcceptedVersions(s -> true)
.serverAcceptedVersions(s -> true)
.simpleChannel();
⋮----
net.messageBuilder(CorruptionDataSyncS2CPacket.class, id(), NetworkDirection.PLAY_TO_CLIENT)
.decoder(CorruptionDataSyncS2CPacket::new)
.encoder(CorruptionDataSyncS2CPacket::toBytes)
.consumerMainThread(CorruptionDataSyncS2CPacket::handle)
.add();
⋮----
public static <MSG> void sendToAll(MSG message) {
INSTANCE.send(PacketDistributor.ALL.noArg(), message);
⋮----
public static <MSG> void sendToPlayer(MSG message, ServerPlayer player) {
INSTANCE.send(PacketDistributor.PLAYER.with(() -> player), message);
</file>

<file path="src/main/java/com/roesilej/corruptedmc/network/packet/CorruptionDataSyncS2CPacket.java">
public class CorruptionDataSyncS2CPacket {
⋮----
this.corruptionLevel = buf.readFloat();
⋮----
public void toBytes(FriendlyByteBuf buf) {
buf.writeFloat(this.corruptionLevel);
⋮----
public boolean handle(Supplier<NetworkEvent.Context> supplier) {
NetworkEvent.Context context = supplier.get();
context.enqueueWork(() -> {
// We are on the client thread here
ClientCorruptionData.setCorruptionLevel(this.corruptionLevel);
</file>

<file path="src/main/resources/assets/corruptedmc/blockstates/corrupted_block.json">
{
  "variants": {
    "": { "model": "corruptedmc:block/corrupted_block" }
  }
}
</file>

<file path="src/main/resources/assets/corruptedmc/models/block/corrupted_block.json">
{
  "parent": "minecraft:block/cube_all",
  "textures": {
    "all": "corruptedmc:block/corrupted_block"
  }
}
</file>

<file path="src/main/resources/assets/corruptedmc/models/item/corrupted_block.json">
{
  "parent": "corruptedmc:block/corrupted_block"
}
</file>

<file path="src/main/resources/META-INF/mods.toml">
# This is an example mods.toml file. It contains the data relating to the loading mods.
# There are several mandatory fields (#mandatory), and many more that are optional (#optional).
# The overall format is standard TOML format, v0.5.0.
# Note that there are a couple of TOML lists in this file.
# Find more information on toml format here:  https://github.com/toml-lang/toml
# The name of the mod loader type to load - for regular FML @Mod mods it should be javafml
modLoader="javafml" #mandatory
# A version range to match for said mod loader - for regular FML @Mod it will be the forge version
loaderVersion="${loader_version_range}" #mandatory This is typically bumped every Minecraft version by Forge. See our download page for lists of versions.
# The license for you mod. This is mandatory metadata and allows for easier comprehension of your redistributive properties.
# Review your options at https://choosealicense.com/. All rights reserved is the default copyright stance, and is thus the default here.
license="${mod_license}"
# A URL to refer people to when problems occur with this mod
#issueTrackerURL="https://change.me.to.your.issue.tracker.example.invalid/" #optional
# If your mod is purely client-side and has no multiplayer functionality (be it dedicated servers or Open to LAN),
# set this to true, and Forge will set the correct displayTest for you and skip loading your mod on dedicated servers.
#clientSideOnly=true #optional - defaults to false if absent
# A list of mods - how many allowed here is determined by the individual mod loader
[[mods]] #mandatory
# The modid of the mod
modId="corruptedmc"
# The version number of the mod
version="0.1.0" 
# A display name for the mod
displayName="Corrupted MC"
# A URL to query for updates for this mod. See the JSON update specification https://docs.minecraftforge.net/en/latest/misc/updatechecker/
#updateJSONURL="https://change.me.example.invalid/updates.json" #optional
# A URL for the "homepage" for this mod, displayed in the mod UI
#displayURL="https://change.me.to.your.mods.homepage.example.invalid/" #optional
# A file name (in the root of the mod JAR) containing a logo for display
#logoFile="examplemod.png" #optional
# A text field displayed in the mod UI
#credits="" #optional
# A text field displayed in the mod UI
authors="Roesilej"
# Display Test controls the display for your mod in the server connection screen
# MATCH_VERSION means that your mod will cause a red X if the versions on client and server differ. This is the default behaviour and should be what you choose if you have server and client elements to your mod.
# IGNORE_SERVER_VERSION means that your mod will not cause a red X if it's present on the server but not on the client. This is what you should use if you're a server only mod.
# IGNORE_ALL_VERSION means that your mod will not cause a red X if it's present on the client or the server. This is a special case and should only be used if your mod has no server component.
# NONE means that no display test is set on your mod. You need to do this yourself, see IExtensionPoint.DisplayTest for more information. You can define any scheme you wish with this value.
# IMPORTANT NOTE: this is NOT an instruction as to which environments (CLIENT or DEDICATED SERVER) your mod loads on. Your mod should load (and maybe do nothing!) whereever it finds itself.
#displayTest="MATCH_VERSION" # if nothing is specified, MATCH_VERSION is the default when clientSideOnly=false, otherwise IGNORE_ALL_VERSION when clientSideOnly=true (#optional)

# The description text for the mod (multi line!) (#mandatory)
description='''
A mod that corrupts the game over time.
'''
# A dependency - use the . to indicate dependency for a specific modid. Dependencies are optional.
[[dependencies.${mod_id}]] #optional
    # the modid of the dependency
    modId="forge" #mandatory
    # Does this dependency have to exist - if not, ordering below must be specified
    mandatory=true #mandatory
    # The version range of the dependency
    versionRange="${forge_version_range}" #mandatory
    # An ordering relationship for the dependency - BEFORE or AFTER required if the dependency is not mandatory
    # BEFORE - This mod is loaded BEFORE the dependency
    # AFTER - This mod is loaded AFTER the dependency
    ordering="NONE"
    # Side this dependency is applied on - BOTH, CLIENT, or SERVER
    side="BOTH"
# Here's another dependency
[[dependencies.${mod_id}]]
    modId="minecraft"
    mandatory=true
    # This version range declares a minimum of the current minecraft version up to but not including the next major version
    versionRange="${minecraft_version_range}"
    ordering="NONE"
    side="BOTH"

# Features are specific properties of the game environment, that you may want to declare you require. This example declares
# that your mod requires GL version 3.2 or higher. Other features will be added. They are side aware so declaring this won't
# stop your mod loading on the server for example.
#[features.${mod_id}]
#openGLVersion="[3.2,)"
</file>

<file path="src/main/resources/pack.mcmeta">
{
  "pack": {
    "description": {
      "text": "${mod_id} resources"
    },
    "pack_format": 15
  }
}
</file>

<file path="gradle.properties">
# Sets default memory used for gradle commands. Can be overridden by user or command line properties.
# This is required to provide enough memory for the Minecraft decompilation process.
org.gradle.jvmargs=-Xmx3G
org.gradle.daemon=false


## Environment Properties

# The Minecraft version must agree with the Forge version to get a valid artifact
minecraft_version=1.20.1
# The Minecraft version range can use any release version of Minecraft as bounds.
# Snapshots, pre-releases, and release candidates are not guaranteed to sort properly
# as they do not follow standard versioning conventions.
minecraft_version_range=[1.20.1,1.21)
# The Forge version must agree with the Minecraft version to get a valid artifact
forge_version=47.4.0
# The Forge version range can use any version of Forge as bounds or match the loader version range
forge_version_range=[47,)
# The loader version range can only use the major version of Forge/FML as bounds
loader_version_range=[47,)
# The mapping channel to use for mappings.
# The default set of supported mapping channels are ["official", "snapshot", "snapshot_nodoc", "stable", "stable_nodoc"].
# Additional mapping channels can be registered through the "channelProviders" extension in a Gradle plugin.
#
# | Channel   | Version              |                                                                                |
# |-----------|----------------------|--------------------------------------------------------------------------------|
# | official  | MCVersion            | Official field/method names from Mojang mapping files                          |
# | parchment | YYYY.MM.DD-MCVersion | Open community-sourced parameter names and javadocs layered on top of official |
#
# You must be aware of the Mojang license when using the 'official' or 'parchment' mappings.
# See more information here: https://github.com/MinecraftForge/MCPConfig/blob/master/Mojang.md
#
# Parchment is an unofficial project maintained by ParchmentMC, separate from Minecraft Forge.
# Additional setup is needed to use their mappings, see https://parchmentmc.org/docs/getting-started
mapping_channel=official
# The mapping version to query from the mapping channel.
# This must match the format required by the mapping channel.
mapping_version=1.20.1


## Mod Properties

# The unique mod identifier for the mod. Must be lowercase in English locale. Must fit the regex [a-z][a-z0-9_]{1,63}
# Must match the String constant located in the main mod class annotated with @Mod.
mod_id=corruptedmc
# The human-readable display name for the mod.
mod_name=Corrupted MC
# The license of the mod. Review your options at https://choosealicense.com/. All Rights Reserved is the default.
mod_license=All Rights Reserved
# The mod version. See https://semver.org/
mod_version=0.1.0
# The group ID for the mod. It is only important when publishing as an artifact to a Maven repository.
# This should match the base package used for the mod sources.
# See https://maven.apache.org/guides/mini/guide-naming-conventions.html
mod_group_id=com.roesilej.corruptedmc
# The authors of the mod. This is a simple text string that is used for display purposes in the mod list.
mod_authors=Roesilej
# The description of the mod. This is a simple multiline text string that is used for display purposes in the mod list.
mod_description=A mod that slowly corrupts the game over time.
</file>

<file path="src/main/java/com/roesilej/corruptedmc/client/ClientEvents.java">
// This annotation tells Forge to listen for events in this class
⋮----
public class ClientEvents {
⋮----
// This is the new, correct way to register a HUD overlay
⋮----
public static void registerGuiOverlays(final RegisterGuiOverlaysEvent event) {
event.registerAboveAll("corruption_hud", (gui, guiGraphics, partialTick, screenWidth, screenHeight) -> {
// We call the render method from our existing overlay class
CorruptionHudOverlay.render(guiGraphics, screenWidth, screenHeight);
⋮----
// --- We can keep your title screen renderer here too ---
// This part of your code was fine, it just needed to be registered.
// By placing it in this annotated class, it will be automatically registered by Forge.
public static class ForgeEvents {
⋮----
public static void onScreenRender(ScreenEvent.Render.Post event) {
if (event.getScreen() instanceof TitleScreen) {
// Your existing code for rendering the version on the title screen
String text = "Corrupted MC v0.1.0"; // Simplified for this example
int screenWidth = event.getScreen().width;
int y = event.getScreen().height - 22;
int stringWidth = event.getScreen().getMinecraft().font.width(text);
⋮----
event.getGuiGraphics().drawString(
event.getScreen().getMinecraft().font,
</file>

<file path="src/main/java/com/roesilej/corruptedmc/corruption/CorruptionData.java">
public class CorruptionData extends SavedData {
⋮----
public float getCorruptionLevel() {
⋮----
public void setCorruptionLevel(float newLevel) {
this.corruptionLevel = Math.max(0.0f, newLevel); // Ensure corruption doesn't go below 0
setDirty(); // Mark this data as needing to be saved
⋮----
public void increaseCorruption(float amount) {
setCorruptionLevel(this.corruptionLevel + amount);
⋮----
public static CorruptionData get(Level level) {
⋮----
throw new RuntimeException("Don't access saved data from the client!");
⋮----
// Get the overworld's data storage
DimensionDataStorage storage = ((ServerLevel)level.getServer().overworld()).getDataStorage();
⋮----
// Get the data, or create it if it doesn't exist
return storage.computeIfAbsent(CorruptionData::load, CorruptionData::new, "corruptiondata");
⋮----
public static CorruptionData load(CompoundTag nbt) {
CorruptionData data = new CorruptionData();
data.corruptionLevel = nbt.getFloat("corruption_level");
⋮----
public CompoundTag save(CompoundTag nbt) {
nbt.putFloat("corruption_level", this.corruptionLevel);
</file>

<file path="src/main/java/com/roesilej/corruptedmc/event/ServerEvents.java">
public class ServerEvents {
⋮----
public static void onServerTick(TickEvent.ServerTickEvent event) {
⋮----
ServerLevel overworld = event.getServer().overworld();
CorruptionData data = CorruptionData.get(overworld);
float corruptionLevel = data.getCorruptionLevel();
⋮----
// --- 1. Existing Logic: Increase Corruption ---
if (overworld.getRandom().nextFloat() < CorruptionRateConfig.getEffectiveRate()) {
data.increaseCorruption(0.01f);
ModMessages.sendToAll(new CorruptionDataSyncS2CPacket(data.getCorruptionLevel()));
⋮----
if (corruptionLevel > 1.0f && overworld.getRandom().nextFloat() < (corruptionLevel / 5000.0f)) {
triggerCorruptionSpreadEvent(overworld, data);
⋮----
public static void onPlayerLoggedIn(PlayerEvent.PlayerLoggedInEvent event) {
if (event.getEntity() instanceof ServerPlayer player) {
// Send the current corruption data to the player who just joined
float corruptionLevel = CorruptionData.get(player.level()).getCorruptionLevel();
ModMessages.sendToPlayer(new CorruptionDataSyncS2CPacket(corruptionLevel), player);
⋮----
/**
     * This method is called when the server is ready to register commands.
     */
⋮----
public static void onRegisterCommands(RegisterCommandsEvent event) {
// Register our new command class
SetCorruptionRateCommand.register(event.getDispatcher());
TriggerEventCommand.register(event.getDispatcher());
⋮----
private static void triggerCorruptionSpreadEvent(ServerLevel world, CorruptionData data) {
// Pick a random player
if (world.getServer().getPlayerCount() == 0) return;
ServerPlayer player = world.getServer().getPlayerList().getPlayers().get(world.getRandom().nextInt(world.getServer().getPlayerCount()));
⋮----
// Try to find a suitable block to corrupt around the player
for (int i = 0; i < 10; i++) { // Try 10 times to find a spot
BlockPos targetPos = player.blockPosition().offset(
world.getRandom().nextInt(16) - 8,
world.getRandom().nextInt(8) - 4,
world.getRandom().nextInt(16) - 8
⋮----
BlockState targetState = world.getBlockState(targetPos);
// We can reuse the same validation logic from the CorruptedBlock class
if (targetState.is(Blocks.STONE) || targetState.is(Blocks.DIRT) || targetState.is(Blocks.GRASS_BLOCK)) {
world.setBlock(targetPos, ModBlocks.CORRUPTED_BLOCK.get().defaultBlockState(), 3);
return; // Exit after corrupting one block
</file>

<file path="src/main/java/com/roesilej/corruptedmc/client/CorruptionHudOverlay.java">
public class CorruptionHudOverlay {
public static void render(GuiGraphics guiGraphics, int screenWidth, int screenHeight) {
if (!Minecraft.getInstance().options.renderDebug) {
⋮----
float corruptionLevel = ClientCorruptionData.getCorruptionLevel();
String text = "Corruption: " + String.format("%.2f%%", corruptionLevel);
⋮----
int stringWidth = Minecraft.getInstance().font.width(text);
⋮----
guiGraphics.drawString(Minecraft.getInstance().font, text, centeredX, y, 0xFFFFFF, true);
</file>

<file path="src/main/java/com/roesilej/corruptedmc/CorruptedMC.java">
public class CorruptedMC {
⋮----
private static final Logger LOGGER = LogUtils.getLogger();
⋮----
IEventBus modEventBus = FMLJavaModLoadingContext.get().getModEventBus();
⋮----
ModBlocks.BLOCKS.register(modEventBus);
ModItems.ITEMS.register(modEventBus);
⋮----
// Register the commonSetup method for modloading
modEventBus.addListener(this::commonSetup);
⋮----
// Register server-side events like commands and server ticks
MinecraftForge.EVENT_BUS.register(ServerEvents.class);
MinecraftForge.EVENT_BUS.register(ClientEvents.ForgeEvents.class);
⋮----
private void commonSetup(final FMLCommonSetupEvent event) {
event.enqueueWork(() -> {
ModMessages.register();
</file>

</files>
